<h1 id="getting-creative-with-the-built-in-geometries">Getting Creative with The Built-In Geometries</h1>
<p>The three.js core includes a large selection of basic geometric shapes. We&rsquo;ve already seen two of these: <a href="/book/first-steps/first-scene/#the-geometry">our trusty <code>BoxBufferGeometry</code></a>, and the <code>SphereBufferGeometry</code> we introduced in the last chapter. There are many other shapes besides these two, from basic cylinders and circles to exotic dodecahedrons. You can use these geometries like an infinite box of stretchy, squishy Lego to build nearly anything your imagination can come up with.</p>
<p>The built-in geometries range from the mundane:</p>
<figure >
  <img src="/static/images/first-steps/geometries_basic.svg" loading="lazy" alt="Box, Cylinder and Sphere geometries" title="Box, Cylinder and Sphere geometries"  /></figure>
<p>&hellip; to the exotic:</p>
<figure >
  <img src="/static/images/first-steps/geometries_exotic.svg" loading="lazy" alt="Dodecahedron, Icosahedron and TorusKnot geometries" title="Dodecahedron, Icosahedron and TorusKnot geometries"  /></figure>
<p>&hellip; to the specialized:</p>
<figure >
  <img src="/static/images/first-steps/geometries_specialized.svg" loading="lazy" alt="Extrude, Lathe and Text geometries" title="Extrude, Lathe and Text geometries"  /></figure>
<p>&hellip; and many more besides. Search for &ldquo;Geometry&rdquo; in the <a href="https://threejs.org/docs/" target="_blank" rel="noopener noreferrer">docs</a> to see all of them.</p>







<figure id="scene-569384172" class="inline-scene loading-dots round medium right"></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/toy-train.js";
  init("#scene-569384172");
</script>

<p>In this chapter, we&rsquo;ll use the transformations we learned a few chapters ago (<a href="/book/first-steps/transformations/">translate, rotate, and scale</a>) to manipulate these geometries and build a simple toy train model. At the same time, we&rsquo;ll use this as an opportunity to explore ways of structuring scene components that are more complex than anything we have created so far. We&rsquo;ll also take a deeper look at using transformations, in particular rotation, which is the trickiest of the three transformations to use. We&rsquo;ll use just two of the geometries to build the toy train: a box geometry for the cabin, and a cylinder geometries for the wheels, nose, and chimney.</p>
<aside class="success">
  
    <h3 id="geometry-and-buffergeometry"><code>Geometry</code> and <code>BufferGeometry</code></h3>
<p>Technically speaking, the geometries we will create are &ldquo;buffer&rdquo; geometries, which means that their data is stored in flat arrays called <em><strong>buffers</strong></em>. <code>BoxBufferGeometry</code> is an extension of the <a href="https://threejs.org/docs/#api/en/core/BufferGeometry" target="_blank" rel="noopener noreferrer"><code>BufferGeometry</code></a> class. This is a newer and faster way of representing geometries, compared to the old <code>Geometry</code> class. Until three.js r125, both <code>Geometry</code> and <code>BufferGeometry</code> were included in the three.js core, but as of three.js r126, <code>Geometry</code> has been removed. It&rsquo;s still available in the examples folder, but you&rsquo;ll have to include it manually if you want to use it.</p>
<p>However, unless you have a good reason and know what you are doing, <strong>you should <em>always</em> use <code>BufferGeometry</code></strong>. <code>Geometry</code> remains <a href="https://github.com/mrdoob/three.js/blob/master/examples/jsm/deprecated/Geometry.js" target="_blank" rel="noopener noreferrer">in the examples folder on the repo</a> for backward compatibility only.</p>

  
</aside>
<h2 id="the-materialflatshading-property">The <code>Material.flatShading</code> Property</h2>
<p>We&rsquo;ll also introduce a new material property in this chapter. <a href="https://threejs.org/docs/#api/en/materials/Material.flatShading" target="_blank" rel="noopener noreferrer"><code>Material.flatShading</code> </a> is defined in the base <code>Material</code> class, which means it&rsquo;s available for every kind of material. By default, it&rsquo;s set to false.</p>
<p><a href="/book/first-steps/organizing-with-group/#introducing-spherebuffergeometry">As we mentioned in the previous chapter</a>, all geometries are made out of triangles. <strong>The only shapes you can draw using WebGL are points, lines, and triangles</strong>, and all other shapes are made from these. However, <strong><code>Mesh</code> objects are made exclusively from triangles</strong>, never points or lines. When they are part of a mesh, these triangles are referred to as <strong>faces</strong>. To create smooth curves, the triangles need to be very tiny. However, to reduce the number of triangles needed faces next to each other are usually blended in lighting calculations. We&rsquo;ll explain how this works in more detail once we get around to explaining what <em><strong>normals</strong></em> are later in the book.</p>
<p>If you turn on <code>.flatShading</code>, adjacent faces are no longer blended. You can use this to give an object a carved or faceted look, which can be a nice effect for low-poly objects like our train.</p>







<figure id="scene-527491683" class="inline-scene loading-dots "><figcaption>Left: flat shading disabled. Right: flat shading enabled.</figcaption></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/flatshading.js";
  init("#scene-527491683");
</script>

<p>You can create a material with flat shading enabled by passing the parameter into the constructor:</p>


<section class="highlight-wrapper"><span class="caption">Create a red flat-shaded <code>MeshStandardMaterial</code></span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const material = new MeshStandardMaterial({
  color: &#39;red&#39;,
  flatShading: true,
});
</code>
  </pre>
</section>

<p>You can also set the <code>material.flatShading</code> property after creating the material. However, if you have already used the material in a rendered scene (technically, if the material has been <em>compiled</em>), you will also need to set the <a href="https://threejs.org/docs/#api/en/materials/Material.needsUpdate" target="_blank" rel="noopener noreferrer"><code>material.needsUpdate</code></a> flag:</p>


<section class="highlight-wrapper"><span class="caption">Once the material has compiled, set the <code>.needsUpdate</code> flag when changing certain properties</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const material = new MeshStandardMaterial({
  color: &#39;red&#39;,
  flatShading: false, // default
});

material.flatShading = true;
material.needsUpdate = true;
</code>
  </pre>
</section>

<h2 id="introducing-the-cylinderbuffergeometry">Introducing the <code>CylinderBufferGeometry</code></h2>
<p>This is the first time we&rsquo;ve used a <a href="https://threejs.org/docs/#api/en/geometries/CylinderBufferGeometry" target="_blank" rel="noopener noreferrer"><code>CylinderBufferGeometry</code></a>, so let&rsquo;s take a moment to examine it now.</p>
<figure class="">
  <iframe title="The CylinderBufferGeometry in action" width="100%" height="500px" src="https://threejs.org/docs/scenes/geometry-browser.html#CylinderBufferGeometry" importance="low" loading="lazy" sandbox="allow-scripts"></iframe><figcaption>The CylinderBufferGeometry in action</figcaption></figure>
<p>The first three parameters define the shape and size of the cylinder:</p>
<ul>
<li><strong><code>radiusTop</code>: the radius of the top of the cylinder.</strong></li>
<li><strong><code>radiusBottom</code>: the radius of the bottom of the cylinder.</strong></li>
<li><strong><code>height</code>: the height of the cylinder.</strong></li>
</ul>
<p>By making <code>radiusTop</code> and <code>radiusBottom</code> different sizes you can create cones instead of cylinders. There is also a <a href="https://threejs.org/docs/#api/en/geometries/ConeBufferGeometry" target="_blank" rel="noopener noreferrer"><code>ConeBufferGeometry</code></a>, but under the hood, it&rsquo;s just a <code>CylinderBufferGeometry</code> with <code>radiusBottom</code> set to zero.</p>
<p>The next two parameters define how detailed the geometry is:</p>
<ul>
<li><strong><code>radialSegments</code>: how detailed the cylinder is around its curved edge. The default is 8, but you&rsquo;ll want to increase this in most cases to make the cylinder more smooth.</strong></li>
<li><strong><code>heightSegments</code>: how detailed the cylinder is along its height. The default value of 1 is usually fine.</strong></li>
</ul>
<p>The final three parameters define how <em>complete</em> the cylinder is:</p>
<ul>
<li><strong><code>openEnded</code>: whether to draw caps on the top and bottom of the cylinder.</strong></li>
<li><strong><code>thetaStart</code>: what point around the curvature the cylinder is drawn from.</strong></li>
<li><strong><code>thetaLength</code>: how far around the curvature to draw.</strong></li>
</ul>
<p>By setting <code>openEnded</code> to false, you can create a tube instead of a cylinder. <code>thetaStart</code> and <code>thetaLength</code> are easily understood if you play around with them in the live example above, or in your own code. You don&rsquo;t have to supply all the parameters when creating a <code>CylinderBufferGeometry</code>. In most cases, the first four are sufficient</p>
<p>By varying the initial parameters, this &ldquo;cylinder&rdquo; geometry can be used to create cones, tubes, and various trough-like shapes. Most of the other geometries are similarly flexible, which means the initial set of twenty geometries can be used to create a near-infinite variety of shapes.</p>
<h2 id="helpers">Helpers</h2>
<p>In the editor, we&rsquo;ve added a couple of helpers to make it easier for you to build the train. There&rsquo;s an <a href="https://threejs.org/docs/#api/en/helpers/AxesHelper" target="_blank" rel="noopener noreferrer"><code>AxesHelper</code></a>, which is three lines representing the $X$, $Y$, and $Z$ axes, and a <a href="https://threejs.org/docs/#api/en/helpers/GridHelper" target="_blank" rel="noopener noreferrer"><code>GridHelper</code></a>, which is a rectangular grid with thick black lines going through the center of the scene, and smaller gray lines at one-unit intervals.</p>
<p>You&rsquo;ll often find it useful to add helpers like this when constructing your scenes, especially while you&rsquo;re getting used to working with the three.js coordinate system. There are many other helpers besides these two to help us visualize all kinds of things our scenes, like boxes, cameras, lights, arrows, planes, and so on.</p>
<p>Here, note the colors of the lines in the axes helper: RGB, representing XYZ: the $X$-axis is red, the $Y$-axis is green, and the $Z$-axis is blue. Next, note that each square of the grid helper is a $1 \times 1$ square, which you can use to help visualize the size of pieces of the train. Our final train will be about nine meters long, perhaps a little big for a toy train (or perhaps not), but we won&rsquo;t worry about that for now. You can also adjust the size of the squares in the helper, which is useful when building large or small scenes.</p>
<h2 id="working-with-rotations">Working With Rotations</h2>
<figure class="medium left">
  <img src="/static/images/first-steps/coordinate_system.svg" loading="lazy" alt="The World Space Coordinate System" title="The World Space Coordinate System"  />
    <figcaption>The World Space Coordinate System</figcaption></figure>
<p>To build the train, we&rsquo;ll create several shapes and then transform (translate, rotate, and scale) them into position. Although we covered the technical details of 3D transformations a few chapters ago, putting the theory into practice takes some work. Translating and scaling objects usually works as you expect, as long as you keep the coordinate system firmly in mind. On the other hand, <a href="/book/first-steps/transformations/#our-final-transformation-rotation">working with rotations</a> can be tricky. Here, we&rsquo;ll take a few moments to examine the rotation operations we&rsquo;ll need to build the train.</p>
<p>Look at the <a href="/book/first-steps/transformations/#coordinate-systems-world-space-and-local-space">world space coordinate system</a> above. The origin, $(0,0,0)$, is at the very center of your scene. Keep this diagram in mind while working with transformations throughout this chapter. Also, note how the colors in the diagram match the colors of the axes helper in the editor: RGB for XYZ.</p>
<p style="clear:both; margin: 0; padding: 0; line-height: 0;">&nbsp</p>







<figure id="scene-397125684" class="inline-scene loading-dots small right"></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/toy-train-rotated.js";
  init("#scene-397125684");
</script>

<p>Next, take a look at the train. The cabin is made from a box geometry, and everything else is made from cylinders. Even the chimney is a cylinder with a smaller radius at the bottom than at the top. The red nose is oriented along the $X$-axis, while the black wheels are orientated along the $Z$-axis. Finally, the chimney is oriented upwards along the $Y$-axis. When we say a cylinder is oriented <em>along an axis</em>, we mean the axis is parallel to a line drawn through the center of the cylinder.</p>
<p>Before we proceed to move the pieces into position, remember, <strong>the direction of a positive rotation in three.js is anti-clockwise</strong>. This is probably the opposite to what your intuition expects, and it&rsquo;s also the opposite of CSS rotations, so make a special note of this:</p>
<blockquote>
<p><strong>Positive Rotation = Anti-Clockwise!</strong></p>
</blockquote>
<figure class="medium left">
  <img src="/static/images/first-steps/cylinder_initial_rotation.svg" loading="lazy" alt="`CylinderBufferGeometry` initial orientation" title="`CylinderBufferGeometry` initial orientation"  />
    <figcaption><code>CylinderBufferGeometry</code> initial orientation</figcaption></figure>
<p>When we create a <code>CylinderBufferGeometry</code>, it starts out pointing upwards like a tree trunk, <strong>oriented along the $Y$-axis</strong>. How do we work out the rotations required to move this into position, to create the wheel, chimney, and nose? Of course, we <em>could</em> use trial and error. However, we&rsquo;d prefer to use a more sophisticated approach.</p>
<p style="clear:both; margin: 0; padding: 0; line-height: 0;">&nbsp</p>
<figure class="medium right">
  <img src="/static/images/first-steps/cylinder_final_rotation.svg" loading="lazy" alt="The cylinder after $90^{\circ}$ rotation around Z" title="The cylinder after $90^{\circ}$ rotation around Z"  />
    <figcaption>The cylinder after $90^{\circ}$ rotation around Z</figcaption></figure>
<p>Let&rsquo;s consider the large red nose first. We want the nose to lie along the $X$-axis. This means we need to rotate it by $90^{\circ}$, or $\frac{\pi}{2}$ radians, <strong>anti-clockwise</strong> around the $Z$-axis.</p>
<p style="clear:both; margin: 0; padding: 0; line-height: 0;">&nbsp</p>
<figure class="medium left">
  <img src="/static/images/first-steps/wheel_initial_rotation.svg" loading="lazy" alt="Initial orientation of the wheels" title="Initial orientation of the wheels"  />
    <figcaption>Initial orientation of the wheels</figcaption></figure>
<p>That account for the nose. What about the wheels? Once again, the cylinder we&rsquo;ll create for the wheels begins its life pointing upwards along the $Y$-axis.</p>
<p style="clear:both; margin: 0; padding: 0; line-height: 0;">&nbsp</p>
<figure class="medium right">
  <img src="/static/images/first-steps/wheel_final_rotation.svg" loading="lazy" alt="Wheel geometry&#39;s final rotation" title="Wheel geometry&#39;s final rotation"  />
    <figcaption>The cylinder after $90^{\circ}$ rotation around X</figcaption></figure>
<p>We want the wheels to lie parallel to the $Z$-axis, so this time, we&rsquo;ll rotate around the $X$-axis. Again, it&rsquo;s a $90^{\circ}$ anti-clockwise (positive) rotation.</p>
<p style="clear:both; margin: 0; padding: 0; line-height: 0;">&nbsp</p>
<p>The final mesh we need to consider is the chimney. Once again, we&rsquo;ll create a geometry (this time, cone-shaped) that starts out pointing up along the $Y$-axis. The chimney also points upwards, so we won&rsquo;t need to rotate this mesh after creating it.</p>
<p>When working with rotations, often, we&rsquo;ll use the<a href="https://threejs.org/docs/#api/en/math/MathUtils.degToRad" target="_blank" rel="noopener noreferrer"> three.js helper function <code>.degToRad</code></a> to <a href="/book/first-steps/animation-loop/#scale-the-cubes-rotation-by-delta">convert from degrees to radians</a>. However, many degree values are easy to write as radians since $180^{\circ} = \pi$ radians, so simple division will give us a range of other radian values, in particular, $90^{\circ} = \frac{\pi}{2}$ and $45^{\circ} = \frac{\pi}{4}$.</p>


<section class="highlight-wrapper"><span class="caption">Various clockwise and anti-clockwise rotations</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
// 90 degrees anti-clockwise around the X-axis
mesh.rotation.x = Math.PI / 2;

// 90 degrees clockwise around the X-axis
mesh.rotation.x = -Math.PI / 2;

// 90 degrees anti-clockwise around the Y-axis
mesh.rotation.y = Math.PI / 2;

// 90 degrees clockwise around the Z-axis
mesh.rotation.z = -Math.PI / 2;

// 45 degrees clockwise around the X-axis
mesh.rotation.x = -Math.PI / 4;

// 45 degrees anti-clockwise around the Y-axis
mesh.rotation.y = Math.PI / 4;
</code>
  </pre>
</section>

<h2 id="a-simple-toy-train-model">A Simple Toy Train Model</h2>
<p>With all that talk of rotations under our belts, hopefully, it will be easy to build the train, so let&rsquo;s get started. We&rsquo;ll also use this simple model as an opportunity to build a template for future, more complex scene components. To that end, we&rsquo;ll create separate modules for geometries, materials, and meshes, and then create a <code>Train</code> class to coordinate the other modules and provide a minimal interface for use within <code>World</code>.</p>
<p>If this sounds familiar to you, it&rsquo;s because this is a microcosm of how we set up <a href="/book/first-steps/world-app/#the-world-app">the World app</a>. There are two reasons for this:</p>
<ol>
<li><strong>Familiarity</strong>: The more similar individual sections of our code are, the less we have to think when switching focus.</li>
<li><strong>Reusability</strong>: Just as we want to be able to hand the <em><strong>World/</strong></em> folder over to another developer with a single paragraph of instructions on how to use it, we want to be able to copy the <em><strong>Train/</strong></em> component between our apps with zero effort.</li>
</ol>
<p>On the other hand, this structure won&rsquo;t be the best for every possible component you create. Always make sure the structure of your code supports what you are trying to build, rather than making you fight against it.</p>
<p>In the editor, we have deleted the <em><strong>meshGroup.js</strong></em> module from the previous chapter and replaced it with a new <em><strong>components/Train/</strong></em> folder. If you&rsquo;re working on your own machine, go ahead and do that now. Inside this folder, there are four modules:</p>
<ul>
<li><em><strong>components/Train/geometries.js</strong></em></li>
<li><em><strong>components/Train/materials.js</strong></em></li>
<li><em><strong>components/Train/meshes.js</strong></em></li>
<li><em><strong>components/Train/Train.js</strong></em></li>
</ul>
<h3 id="initial-structure-of-_geometriesjs_-_materialsjs_-and-_meshesjs_">Initial Structure of <em><strong>geometries.js</strong></em>, <em><strong>materials.js</strong></em>, and <em><strong>meshes.js</strong></em></h3>
<p>The first two modules follow a similar format to all the other <a href="/book/first-steps/world-app/#systems-and-components">components and systems</a> we&rsquo;ve created so far.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train/geometries.js</strong></em>: initial structure</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { BoxBufferGeometry, CylinderBufferGeometry } from &#39;three&#39;;

function createGeometries() {}

export { createGeometries }
</code>
  </pre>
</section>



<section class="highlight-wrapper"><span class="caption"><em><strong>Train/materials.js</strong></em>: initial structure</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { MeshStandardMaterial } from &#39;three&#39;;

function createMaterials() {}

export { createMaterials }
</code>
  </pre>
</section>

<p>Finally, the meshes module. This is similar to the other two, however, the meshes will require the geometries and materials created by the other two modules, so import them at the top of the module, after we import <code>Mesh</code> from the three.js core (vendor imports will always go before our local imports). Finally, call each function and store the results in the <code>geometries</code> and <code>materials</code> variables.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train/meshes.js</strong></em>: initial structure</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { Mesh } from &#39;three&#39;;

import { createGeometries } from &#39;./geometries.js&#39;;
import { createMaterials } from &#39;./materials.js&#39;;

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();
}

export { createMeshes }
</code>
  </pre>
</section>

<h3 id="the-train-class-extends-group">The <code>Train</code> Class Extends <code>Group</code></h3>
<p>Next, the <code>Train</code> class. Here, we&rsquo;ll do something new and <a href="/book/appendix/javascript-reference/#class-inheritance-and-the-extends-keyword"><em>extend</em> the <code>Group</code> class</a>:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train.js</strong></em>: extend the group class</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
import { Group } from &#39;three&#39;;

class Train extends Group {
  constructor() {
    super();
  }
}

export { Train }
</code>
  </pre>
</section>

<p>Note the use of <code>super()</code>. This means the <code>Train</code> class now has all the normal functionality of a <code>Group</code>. In particular, we can add objects to it, and we can add it directly to our scene:</p>


<section class="highlight-wrapper"><span class="caption">By extending <code>Group</code>, once we create a train we can add it directly to our scene</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
const train = new Train();

// we can add objects to our train
train.add(mesh);

// and we can add the train directly to the scene
scene.add(train);
</code>
  </pre>
</section>

<p>We can also access add objects to the train from within the class itself, using <code>this.add</code>:</p>


<section class="highlight-wrapper"><span class="caption">By extending <code>Group</code>, we can add a mesh to the train in the constructor</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers hide-line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">
class Train extends Group {
  constructor() {
    super();

    const mesh = new Mesh(...);

    this.add(mesh);
  }
}
</code>
  </pre>
</section>

<h3 id="import-the-meshes">Import the Meshes</h3>
<p>Using this knowledge, we can finish setting up the <code>Train</code> class. First, import the <code>createMeshes</code> function, then call it and store the result in a member variable, <code>this.meshes</code>. At the very end of this chapter, we&rsquo;ll add some animation to the wheels, which means we need to access the meshes from outside the constructor, hence the use of a member variable here.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train.js</strong></em>: import and create the meshes</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="3,4,5,11"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">

import { Group } from &#39;three&#39;;

import { createGeometries } from &#39;./geometries.js&#39;;
import { createMaterials } from &#39;./materials.js&#39;;
import { createMeshes } from &#39;./meshes.js&#39;;

class Train extends Group {
  constructor() {
    super();

    this.meshes = createMeshes();
  }
}

export { Train };

</code>
  </pre>
</section>

<h3 id="_worldjs_-setup"><em><strong>World.js</strong></em> Setup</h3>
<p>Over in World, import the <code>Train</code> class. If you&rsquo;re working with code from the last chapter, remove any references to <code>meshGroup</code> from the file.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: import the train</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="8"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { createCamera } from &#39;./components/camera.js&#39;;
import {
  createAxesHelper,
  createGridHelper,
} from &#39;./components/helpers.js&#39;;
import { createLights } from &#39;./components/lights.js&#39;;
import { createScene } from &#39;./components/scene.js&#39;;
import { Train } from &#39;./components/Train/Train.js&#39;;

import { createControls } from &#39;./systems/controls.js&#39;;
import { createRenderer } from &#39;./systems/renderer.js&#39;;
import { Resizer } from &#39;./systems/Resizer.js&#39;;
import { Loop } from &#39;./systems/Loop.js&#39;;
</code>
  </pre>
</section>

<p>Next, create an instance of the train and add it to the scene.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: create an instance of the train and add it to the scene</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="21"
    data-line="30,32"
    data-line-offset="21"
    >
    <code class="highlight language-js match-braces">

constructor(container) {
  camera = createCamera();
  renderer = createRenderer();
  scene = createScene();
  loop = new Loop(camera, scene, renderer);
  container.append(renderer.domElement);

  const controls = createControls(camera, renderer.domElement);
  const { ambientLight, mainLight } = createLights();
  const train = new Train();

  scene.add(ambientLight, mainLight, train);

  const resizer = new Resizer(container, camera, renderer);

  scene.add(createAxesHelper(), createGridHelper());
}

</code>
  </pre>
</section>

<h3 id="other-changes">Other Changes</h3>
<p>Note that we have also made some minor adjustments to the camera position in <em><strong>camera.js</strong></em>, slightly moved the <a href="/book/first-steps/camera-controls/#manually-set-the-target"><code>controls.target</code></a> in <em><strong>controls.js</strong></em> to better frame the train, as well as reducing the intensity of both lights in <em><strong>lights.js</strong></em>.</p>
<h3 id="create-the-materials">Create the Materials</h3>
<p>At this point, we have finished creating the structure of our new scene component. All that remains is to set up the materials, geometries, and meshes. These don&rsquo;t have to take the form of a train. You can use this structure as a template to create any shape you can dream of.</p>
<p>We&rsquo;ll create two materials for the train: a dark grey material for the chimney and wheels, and a reddish material for the body. We&rsquo;ll use <a href="/book/first-steps/physically-based-rendering/#introducing-the-meshstandardmaterial"><code>MeshStandardMaterial</code></a> with <a href="#the-material-flatshading-property"><code>.flatShading</code></a> enabled for both. Other than <code>.flatShading</code>, there&rsquo;s nothing new here. Here&rsquo;s the complete materials module:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>materials.js</strong></em>: complete code</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line=""
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { MeshStandardMaterial } from &#39;three&#39;;

function createMaterials() {
  const body = new MeshStandardMaterial({
    color: &#39;firebrick&#39;,
    flatShading: true,
  });

  const detail = new MeshStandardMaterial({
    color: &#39;darkslategray&#39;,
    flatShading: true,
  });

  return { body, detail };
}

export { createMaterials };
</code>
  </pre>
</section>

<p>We&rsquo;ve chosen <code>firebrick</code> red for the body and <code>darkslategray</code> for the wheels and chimney, but you can take a look through the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value" target="_blank" rel="noopener noreferrer">list of CSS colors</a> and pick out two that you like. At the end of the module, we return an object containing both materials for use within <em><strong>meshes.js</strong></em>.</p>
<h3 id="create-the-geometries">Create the Geometries</h3>
<p>We&rsquo;ll use just two types of geometry for every part of the train: a box geometry for the cabin, and <a href="#introducing-the-cylinderbuffergeometry">cylinder geometries</a> with various parameters for everything else.</p>
<h4 id="the-cabin-geometry">The Cabin Geometry</h4>
<p>First up, the box-shaped cabin. A single <code>BoxBufferGeometry</code> will suffice here. Create one with the following parameters:</p>
<table>
<thead>
<tr>
<th>Length</th>
<th>Width</th>
<th>Height</th>
</tr>
</thead>
<tbody>
<tr>
<td>$2$</td>
<td>$2.25$</td>
<td>$1.5$</td>
</tr>
</tbody>
</table>


<section class="highlight-wrapper"><span class="caption"><em><strong>geometries.js</strong></em>: create the cabin geometry</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="4"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">

function createGeometries() {
  const cabin = new BoxBufferGeometry(2, 2.25, 1.5);
}

</code>
  </pre>
</section>

<p>Different values for the length, width, and height will give us a rectangular box, unlike the cube we have used in previous chapters.</p>
<h4 id="the-nose-geometry">The Nose Geometry</h4>
<p>Next, create the first <code>CylinderBufferGeometry</code> for the nose, using these parameters:</p>
<table>
<thead>
<tr>
<th>Top radius</th>
<th>Bottom radius</th>
<th>Height</th>
<th>Radial segments</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0.75$</td>
<td>$0.75$</td>
<td>$3$</td>
<td>$12$</td>
</tr>
</tbody>
</table>
<p><code>radiusTop</code> and <code>radiusBottom</code> are equal, so we&rsquo;ll get a cylinder. A value of $12$ for the <code>radialSegments</code>, when combined with <code>Material.flatShading</code>, will make the cylinder look like it has been roughly carved.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>geometries.js</strong></em>: create the nose geometry</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="6"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">

function createGeometries() {
  const cabin = new BoxBufferGeometry(2, 2.25, 1.5);

  const nose = new CylinderBufferGeometry(0.75, 0.75, 3, 12);
}

</code>
  </pre>
</section>

<h4 id="the-wheels-geometry">The Wheels Geometry</h4>
<p>We can reuse a single <code>CylinderBufferGeometry</code> for all four wheels, even the large rear wheel. You can reuse a geometry in any number of meshes, and then change the <code>.position</code>,<code>.rotation</code> and <code>.scale</code> for each mesh. This is more efficient than creating a new geometry for every mesh, and you should do this whenever possible. Create a cylinder geometry with these parameters:</p>
<table>
<thead>
<tr>
<th>Top radius</th>
<th>Bottom radius</th>
<th>Height</th>
<th>Radial segments</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0.4$</td>
<td>$0.4$</td>
<td>$1.75$</td>
<td>$16$</td>
</tr>
</tbody>
</table>
<p>The higher value of 16 for <code>radialSegments</code> will make the wheels look more rounded. We&rsquo;re creating the geometry at the correct size for the three smaller wheels, so, later, we&rsquo;ll have to increase the scale of the larger rear wheel.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>geometries.js</strong></em>: create the wheel geometry</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="9"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">

function createGeometries() {
  const cabin = new BoxBufferGeometry(2, 2.25, 1.5);

  const nose = new CylinderBufferGeometry(0.75, 0.75, 3, 12);

  // we can reuse a single cylinder geometry for all 4 wheels
  const wheel = new CylinderBufferGeometry(0.4, 0.4, 1.75, 16);
}

</code>
  </pre>
</section>

<h4 id="the-chimney-geometry">The Chimney Geometry</h4>
<p>Finally, the chimney. It&rsquo;s a cone, not a cylinder, but as discussed above, if we create a cylinder geometry with different values for <code>radiusTop</code> and <code>radiusBottom</code>, the result will be a cone shape. This time, leave <code>radialSegments</code> at the default value of 8.</p>
<table>
<thead>
<tr>
<th>Top radius</th>
<th>Bottom radius</th>
<th>Height</th>
<th>Radial segments</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0.3$</td>
<td>$0.1$</td>
<td>$0.5$</td>
<td>default value</td>
</tr>
</tbody>
</table>


<section class="highlight-wrapper"><span class="caption"><em><strong>geometries.js</strong></em>: create the chimney geometry</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="3"
    data-line="12"
    data-line-offset="3"
    >
    <code class="highlight language-js match-braces">

function createGeometries() {
  const cabin = new BoxBufferGeometry(2, 2.25, 1.5);

  const nose = new CylinderBufferGeometry(0.75, 0.75, 3, 12);

  // we can reuse a single cylinder geometry for all 4 wheels
  const wheel = new CylinderBufferGeometry(0.4, 0.4, 1.75, 16);

  // different values for the top and bottom radius creates a cone shape
  const chimney = new CylinderBufferGeometry(0.3, 0.1, 0.5);
}

</code>
  </pre>
</section>

<h4 id="final-geometries-module">Final Geometries Module</h4>
<p>Finally, return all of the geometries as an object at the end of the function. Putting all that together, here&rsquo;s the final geometries module:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>geometries.js</strong></em>: final code</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="14-19"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { BoxBufferGeometry, CylinderBufferGeometry } from &#39;three&#39;;

function createGeometries() {
  const cabin = new BoxBufferGeometry(2, 2.25, 1.5);

  const nose = new CylinderBufferGeometry(0.75, 0.75, 3, 12);

  // we can reuse a single cylinder geometry for all 4 wheels
  const wheel = new CylinderBufferGeometry(0.4, 0.4, 1.75, 16);

  // different values for the top and bottom radius creates a cone shape
  const chimney = new CylinderBufferGeometry(0.3, 0.1, 0.5);

  return {
    cabin,
    nose,
    wheel,
    chimney,
  };
}

export { createGeometries };
</code>
  </pre>
</section>

<h3 id="create-the-meshes">Create the Meshes</h3>
<p>All that remains is to create the meshes. First, we&rsquo;ll create the cabin, nose, and chimney individually, then <a href="/book/first-steps/organizing-with-group/#clone-the-protosphere">we&rsquo;ll create one wheel and <code>.clone</code> it</a> to create the other three.</p>
<h4 id="the-cabin-and-chimney-meshes">The Cabin and Chimney Meshes</h4>
<p><a href="/book/first-steps/first-scene/#our-first-visible-object-mesh">Create the cabin and chimney meshes as usual</a>, using the body material for the cabin and the detail material for the chimney, then move each mesh into position.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>meshes.js</strong></em>: create the cabin and chimney</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="6"
    data-line="10,11,13,14"
    data-line-offset="6"
    >
    <code class="highlight language-js match-braces">

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();

  const cabin = new Mesh(geometries.cabin, materials.body);
  cabin.position.set(1.5, 1.4, 0);

  const chimney = new Mesh(geometries.chimney, materials.detail);
  chimney.position.set(-2, 1.9, 0);
}

</code>
  </pre>
</section>

<p>The values entered for the positions are the result of some trial and error. However, with practice, you&rsquo;ll find that positioning objects becomes more intuitive and faster. As we mentioned above, there&rsquo;s no need to rotate the chimney, as it&rsquo;s already oriented correctly when we create it.</p>
<h4 id="the-nose-mesh">The Nose Mesh</h4>
<p>Next up is the big red nose. Create the mesh as normal, using <code>geometries.nose</code> and <code>materials.body</code>. This time <a href="#working-with-rotations">we need to rotate</a> as well as position the mesh:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>meshes.js</strong></em>: create the nose</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="6"
    data-line="16-18"
    data-line-offset="6"
    >
    <code class="highlight language-js match-braces">

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();

  const cabin = new Mesh(geometries.cabin, materials.body);
  cabin.position.set(1.5, 1.4, 0);

  const chimney = new Mesh(geometries.chimney, materials.detail);
  chimney.position.set(-2, 1.9, 0);

  const nose = new Mesh(geometries.nose, materials.body);
  nose.position.set(-1, 1, 0);
  nose.rotation.z = Math.PI / 2;
}

</code>
  </pre>
</section>

<p>This completes the red body of the train, along with the chimney.</p>
<h4 id="create-the-prototype-wheel">Create the Prototype Wheel</h4>
<p>Now, the wheels. We&rsquo;ll create the <code>smallWheelRear</code> first and then clone it to create the rest, just as we did with our <a href="/book/first-steps/organizing-with-group/#create-the-prototype-mesh"><code>protoSphere</code> from the previous chapter</a>. Create the <code>smallWheelRear</code> mesh, and then <strong>translate it down half a unit on the $Y$-axis</strong> to position it under the train. Then, <a href="#working-with-rotations">rotate it to lie along the $X$-axis</a>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>meshes.js</strong></em>: create the first wheel</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="6"
    data-line="20-22"
    data-line-offset="6"
    >
    <code class="highlight language-js match-braces">

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();

  const cabin = new Mesh(geometries.cabin, materials.body);
  cabin.position.set(1.5, 1.4, 0);

  const chimney = new Mesh(geometries.chimney, materials.detail);
  chimney.position.set(-2, 1.9, 0);

  const nose = new Mesh(geometries.nose, materials.body);
  nose.position.set(-1, 1, 0);
  nose.rotation.z = Math.PI / 2;

  const smallWheelRear = new Mesh(geometries.wheel, materials.detail);
  smallWheelRear.position.y = 0.5;
  smallWheelRear.rotation.x = Math.PI / 2;
}

</code>
  </pre>
</section>

<p>When we clone this wheel to create the rest of the wheels, the <strong>cloned meshes will inherit the transformations from the prototype</strong>. This means the cloned wheels will start correctly rotated and positioned at the bottom of the train, and we just need to space them out along the $X$-axis.</p>
<h4 id="create-small-wheels">Create the Other Small Wheels</h4>
<p>Clone the proto-wheel to create the other two small wheels, then move each into position along the $X$-axis:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>meshes.js</strong></em>: create the other small wheels</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="6"
    data-line="24,25,27,28"
    data-line-offset="6"
    >
    <code class="highlight language-js match-braces">

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();

  const cabin = new Mesh(geometries.cabin, materials.body);
  cabin.position.set(1.5, 1.4, 0);

  const chimney = new Mesh(geometries.chimney, materials.detail);
  chimney.position.set(-2, 1.9, 0);

  const nose = new Mesh(geometries.nose, materials.body);
  nose.position.set(-1, 1, 0);
  nose.rotation.z = Math.PI / 2;

  const smallWheelRear = new Mesh(geometries.wheel, materials.detail);
  smallWheelRear.position.y = 0.5;
  smallWheelRear.rotation.x = Math.PI / 2;

  const smallWheelCenter = smallWheelRear.clone();
  smallWheelCenter.position.x = -1;

  const smallWheelFront = smallWheelRear.clone();
  smallWheelFront.position.x = -2;
}

</code>
  </pre>
</section>

<h4 id="create-the-large-rear-wheel">Create The Large Rear Wheel</h4>
<p>The final piece of our train is the large rear wheel. Once again, clone the small wheel, then move it into position at the back of the train. This time, we also need to scale it to make it larger:</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>meshes.js</strong></em>: create the large rear wheel</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="6"
    data-line="30-32"
    data-line-offset="6"
    >
    <code class="highlight language-js match-braces">

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();

  const cabin = new Mesh(geometries.cabin, materials.body);
  cabin.position.set(1.5, 1.4, 0);

  const chimney = new Mesh(geometries.chimney, materials.detail);
  chimney.position.set(-2, 1.9, 0);

  const nose = new Mesh(geometries.nose, materials.body);
  nose.position.set(-1, 1, 0);
  nose.rotation.z = Math.PI / 2;

  const smallWheelRear = new Mesh(geometries.wheel, materials.detail);
  smallWheelRear.position.y = 0.5;
  smallWheelRear.rotation.x = Math.PI / 2;

  const smallWheelCenter = smallWheelRear.clone();
  smallWheelCenter.position.x = -1;

  const smallWheelFront = smallWheelRear.clone();
  smallWheelFront.position.x = -2;

  const bigWheel = smallWheelRear.clone();
  bigWheel.position.set(1.5, 0.9, 0);
  bigWheel.scale.set(2, 1.25, 2);
}

</code>
  </pre>
</section>

<p>By scaling, we have doubled the diameter of the big wheel and increased its length by 1.25. But how did we work out which axes to scale on?</p>
<figure class="medium left noborder">
  <img src="/static/images/first-steps/wheel_initial_rotation.svg" loading="lazy" alt="Initial cylinder geometry orientation" title="Initial cylinder geometry orientation"  />
    <figcaption>Initial cylinder geometry orientation</figcaption></figure>
<p>Look at the initial position of a newly created <code>CylinderBufferGeometry</code> once again. <strong>Scaling happens independently of rotation, so even though we rotated the mesh, we must decide how to scale based on the original, unrotated geometry.</strong> By examining this diagram, we can see that to increase the height, we need to scale on the $Y$-axis, and to increase the diameter, we need to scale by an equal amount on the $X$-axis and $Z$-axis. This gives us the final <code>.scale</code> value of $(2, 1.25, 2)$.</p>
<h4 id="final-meshes-module">Final Meshes Module</h4>
<p>Putting that all together, here&rsquo;s the final <code>.createMeshes</code> module. Once again, we have returned an object containing all the meshes for use in the Train module.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>meshes.js</strong></em>: complete code</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="34-42"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { Mesh } from &#39;three&#39;;

import { createGeometries } from &#39;./geometries.js&#39;;
import { createMaterials } from &#39;./materials.js&#39;;

function createMeshes() {
  const geometries = createGeometries();
  const materials = createMaterials();

  const cabin = new Mesh(geometries.cabin, materials.body);
  cabin.position.set(1.5, 1.4, 0);

  const chimney = new Mesh(geometries.chimney, materials.detail);
  chimney.position.set(-2, 1.9, 0);

  const nose = new Mesh(geometries.nose, materials.body);
  nose.position.set(-1, 1, 0);
  nose.rotation.z = Math.PI / 2;

  const smallWheelRear = new Mesh(geometries.wheel, materials.detail);
  smallWheelRear.position.y = 0.5;
  smallWheelRear.rotation.x = Math.PI / 2;

  const smallWheelCenter = smallWheelRear.clone();
  smallWheelCenter.position.x = -1;

  const smallWheelFront = smallWheelRear.clone();
  smallWheelFront.position.x = -2;

  const bigWheel = smallWheelRear.clone();
  bigWheel.position.set(1.5, 0.9, 0);
  bigWheel.scale.set(2, 1.25, 2);

  return {
    nose,
    cabin,
    chimney,
    smallWheelRear,
    smallWheelCenter,
    smallWheelFront,
    bigWheel,
  };
}

export { createMeshes };
</code>
  </pre>
</section>

<h3 id="add-the-meshes-to-the-train">Add the Meshes to the Train</h3>
<p>Next, we&rsquo;ll add the meshes to the Train. We&rsquo;ll do this in the train&rsquo;s constructor.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train.js</strong></em>: add the meshes to the Train group</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="7"
    data-line="13-21"
    data-line-offset="7"
    >
    <code class="highlight language-js match-braces">

class Train extends Group {
  constructor() {
    super();

    this.meshes = createMeshes();

    this.add(
      this.meshes.nose,
      this.meshes.cabin,
      this.meshes.chimney,
      this.meshes.smallWheelRear,
      this.meshes.smallWheelCenter,
      this.meshes.smallWheelFront,
      this.meshes.bigWheel,
    );
  }
}

</code>
  </pre>
</section>

<p>With that, the train should appear in your scene.</p>







<figure id="scene-718593246" class="inline-scene loading-dots "></figure>

<script type="module">
  import init from "/static/examples/worlds/inline-scenes/first-steps/toy-train-autorotate.js";
  init("#scene-718593246");
</script>

<h3 id="spin-the-wheels">Spin the Wheels!</h3>
<p>As a final touch, let&rsquo;s set the wheels spinning. Give the train a <code>.tick</code> method, following the same <a href="/book/first-steps/animation-loop/#the-cubetick-method">pattern we use for all animated objects</a>.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train.js</strong></em>: create an empty tick method</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="7"
    data-line="12"
    data-line-offset="7"
    >
    <code class="highlight language-js match-braces">

class Train extends Group {
  constructor() {
    // ... lines skipped for clarity
  }

  tick(delta) {}
}

</code>
  </pre>
</section>

<p>Next, over in World, add the train to the updatables array.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>World.js</strong></em>: add the train to the updatables array</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="21"
    data-line="32"
    data-line-offset="21"
    >
    <code class="highlight language-js match-braces">  constructor(container) {
    camera = createCamera();
    renderer = createRenderer();
    scene = createScene();
    loop = new Loop(camera, scene, renderer);
    container.append(renderer.domElement);

    const controls = createControls(camera, renderer.domElement);
    const { ambientLight, mainLight } = createLights();
    const train = new Train();

    loop.updatables.push(controls, train);
    scene.add(ambientLight, mainLight, train);

    const resizer = new Resizer(container, camera, renderer);

    scene.add(createAxesHelper(), createGridHelper());
  }
</code>
  </pre>
</section>

<figure class="small right noborder">
  <img src="/static/images/first-steps/wheel_initial_rotation.svg" loading="lazy" alt="Initial cylinder geometry orientation" title="Initial cylinder geometry orientation"  />
    <figcaption>Initial cylinder geometry orientation</figcaption></figure>
<p>Now, we need to figure out what axis to spin the wheels on. Refer once again to the diagram of the initial cylinder geometry orientation. We want it to spin around the axis going through its center, which is the $Y$-axis. The fact that we have rotated the wheels to lie along the $Z$-axis doesn&rsquo;t change this.</p>
<p>Next, we need to figure out how fast to spin the wheels. We&rsquo;ll spin at a rate of $24^{\circ}$ per second to give us one complete rotation every fifteen seconds. As usual, we must convert this to radians using the <code>degToRad</code> helper function.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train.js</strong></em>: calculate the wheel speed in degrees per second</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="1"
    data-line="1,5"
    data-line-offset="1"
    >
    <code class="highlight language-js match-braces">import { Group, MathUtils } from &#39;three&#39;;

import { createMeshes } from &#39;./meshes.js&#39;;

const wheelSpeed = MathUtils.degToRad(24);

class Train extends Group {
</code>
  </pre>
</section>

<p>Finally, update the tick method to rotate each of the four wheels. We must scale the per-second speed by delta here, as usual. Refer back to <a href="/book/first-steps/animation-loop/#timing-in-the-animation-system">1.7: The Animation Loop</a> for an explanation of why we do this.</p>


<section class="highlight-wrapper"><span class="caption"><em><strong>Train.js</strong></em>: spin the wheels, scaling the per-second speed by delta</span>
  
  <pre
    style="background-color: #202020;"
    class="line-numbers"
    data-start="24"
    data-line="25-28"
    data-line-offset="24"
    >
    <code class="highlight language-js match-braces">  tick(delta) {
    this.meshes.bigWheel.rotation.y &#43;= wheelSpeed * delta;
    this.meshes.smallWheelRear.rotation.y &#43;= wheelSpeed * delta;
    this.meshes.smallWheelCenter.rotation.y &#43;= wheelSpeed * delta;
    this.meshes.smallWheelFront.rotation.y &#43;= wheelSpeed * delta;
  }
</code>
  </pre>
</section>

<p>Once you make this change, the wheel should start to rotate, and with that, our toy train is complete!</p>
<h2 id="beyond-simple-shapes">Beyond Simple Shapes</h2>
<figure class="medium right">
  <iframe title="Creating a complex model like this using the built-in geometries is not possible" width="100%" height="500px" src="https://threejs.org/examples/webgl_materials_normalmap.html" importance="low" loading="lazy" sandbox="allow-scripts"></iframe><figcaption>Creating a complex model like this using the built-in geometries<br> is not possible</figcaption></figure>
<p>The last two chapters have shown us both the strengths and the limitations of the built-in three.js geometries. It&rsquo;s easy to create one hundred or one thousand clones of a mesh in a loop, and it was relatively easy to create a simple model of a toy train. However, creating a real-world object like a cat or a human would soon overwhelm us. Even for a model as basic as this one, the trial and error required to move the pieces of the train into position took some time.</p>
<p>To create truly amazing models, we need to use an external program designed for that purpose and then load the model into three.js. In the next chapter, we&rsquo;ll see how to do just that.</p>
<h2 id="challenges">Challenges</h2>
<aside class="success">
  
    <h3 id="easy">Easy</h3>
<ol>
<li>
<p>What&rsquo;s better than a toy train? How about <em>two</em> toy trains? You can <code>.clone</code> the entire train after creating it. Do that now, and then adjust the <code>.position</code> of the second train. Don&rsquo;t forget to add it to the scene!</p>
</li>
<li>
<p>What&rsquo;s better than two toy trains? <a href="/book/first-steps/organizing-with-group/#clone-the-protosphere">Create a whole bunch of trains in a loop</a>. Within the loop, make sure to move each new train so they are not all stacked on top of each other, and then add each to the scene. See how many interesting ways you can position the cloned trains.</p>
</li>
</ol>
<p><em>Both of these tasks should be done in <strong>World.js</strong>.</em></p>

  
</aside>
<aside class="notice">
  
    <h3 id="medium">Medium</h3>
<ol>
<li>
<p>Can you create a window in the cabin? There&rsquo;s no way to cut holes in the geometries (without using an external library), so you&rsquo;ll have to rebuild the cabin out of several box geometries. One way to do it is to create a large box for the floor, then another large box for the roof, and finally, four small boxes (or cylinders) for the pillars, around the edges of the roof.</p>
</li>
<li>
<p>A train won&rsquo;t go far without tracks! Add some tracks under the wheels. Create the two main tracks, then create a single board under the track and use clone to create the rest.</p>
</li>
<li>
<p>Every train needs a conductor! Create a simple human figure (like a Lego character) standing beside the train.</p>
</li>
</ol>

  
</aside>
<aside class="warning">
  
    <h3 id="hard">Hard</h3>
<ol>
<li>What else can you do to improve this scene? How about some bubbles of smoke coming out of the train&rsquo;s chimney (use <code>SphereBufferGeometry</code> to create the bubbles). What about some clouds in the sky? How about <em>animating</em> the smoke and clouds?</li>
</ol>

  
</aside>
